package slidind_window;

import java.util.*;

public class SlidingWindowMaximumDeque {


    /**
     * это хард алгоритм, дан массив чисел и число К, которое является размером окна,
     * необходимо вернуть массив всех максимумов во время слайда этого окна
     * <p>
     * Input: nums = [1,3,-1,-3,5,3,6,7], and k = 3
     * Output: [3,3,5,5,6,7]
     * Explanation:
     * <p>
     * Window position                Max
     * ---------------               -----
     * [1  3  -1] -3  5  3  6  7       3
     * 1 [3  -1  -3] 5  3  6  7       3
     * 1  3 [-1  -3  5] 3  6  7       5
     * 1  3  -1 [-3  5  3] 6  7       5
     * 1  3  -1  -3 [5  3  6] 7       6
     * 1  3  -1  -3  5 [3  6  7]      7
     * <p>
     * тут очень интересное решение с использованием двусвязной очереди, суть вот
     * в чем - мы создаем двухсвязную очередь для хранения ИНДЕКСОВ массива, эти индексы будут
     * показывать потенциально возможные максимумы нашего ОКНА размером К
     * <p>
     * соответсвенно - раскручиваем цикл, проверяем нашу дэку и индексы в ней, приницип такой -
     * в голове этой очереди будет находится максимальный индекс окна
     * в конец очереди мы добавляем новые индексы каждую итерацию
     * <p>
     * затем - каждую итерацию в начале, мы проверяем и удаляем индексы которые меньше нашего окна, тоесть
     * int startWindowIndex = endWindowIndex - k + 1;
     * смотрим такие индексы, они уже не актуальны
     * <p>
     * второй шаг, взять текущий последний элемент окна  arr[endWindowIndex], и проверить элемент
     * которые в очереди, а они меньше него? если они меньше него то смысла их держать НЕТ! потому
     * что это окно размером К и новый элемент (а именно индекс endWindowIndex) будет добавлен в эту деку
     * и он и будет в теории максимумом
     * <p>
     * ну и все и последним шагом в цикле, мы проверяем  а в принципе мы достигли достаточного размер для окна?
     * если достигли берем голову у нашей деки - это будет индекс,  и добавляем в результирующий массив res
     */
    public static void main(String[] args) {
        // int[] arr = {1, 3, -1, -3, 5, 3, 6, 7};
        int[] arr = {1, 3, 1, 2, 0, 5};
        System.out.println(Arrays.toString(maxSlidingWindow(arr, 3)));
    }

    static int[] maxSlidingWindow(int[] arr, int k) {

        List<Integer> res = new ArrayList<>();

        if (arr == null || k <= 0) {
            return res.stream().mapToInt(i -> i).toArray();
        }

        // будем использовать дэку для хранения индексов
        // нашего окна
        Deque<Integer> dq = new ArrayDeque<>();

        //раскручиваем цикл
        for (int endWindowIndex = 0; endWindowIndex < arr.length; endWindowIndex++) {

            //будем удалять элементы из дэки
            //которые вышли за пределы окна
            int startWindowIndex = endWindowIndex - k + 1;

            //крутимся в цикле до тех пор пока либо наша очередь не опустеет
            //либо мы не достигнем индекса начала нашего окна
            while (!dq.isEmpty() && dq.peek() < startWindowIndex) {
                dq.poll();
            }

            // вот мы в окне и перед нами элемент arr[endWindowIndex]
            //если мы понимаем что голова дэки - тобишь максимум содержит
            //элемент который меньше чем наш элемент
            //то этот элемент (в дэке) нам не нужен, его можно удалить
            while (!dq.isEmpty() && arr[dq.peekLast()] < arr[endWindowIndex]) {
                dq.pollLast();
            }

            // каждую итерацию добавляем новый элемент
            //в КОНЕЦ очереди
            //этот элемент станет ГОЛОВОЙ
            //если все предыдущие элементы были меньше него
            dq.offer(endWindowIndex);

            //ну и теперь смотрим, вписываемся ли мы в наше окно
            //или стоит еще покрутится в цикле и расширить
            if (endWindowIndex >= k - 1) {
                //берем элемент из головы нашей очереди, там
                //всегда будет хранится индекс максимального элемента
                //для данного окна
                Integer indexOfMaxElmInWindow = dq.peek();
                res.add(arr[indexOfMaxElmInWindow]);
            }
        }
        return res.stream().mapToInt(i -> i).toArray();


    }
}
