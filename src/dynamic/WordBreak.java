package dynamic;

import java.util.HashSet;
import java.util.List;

public class WordBreak {

    public static void main(String[] args) {

        String s = "leetcode";

        List<String> dict = List.of("leet", "code");

        System.out.println(wordBreak(s, dict));
    }

    /**
     * динамическое программирование
     * как его тут можно применить, пример можно
     * мы будем искать в нашей подстроке слова
     * как искать слова? - ну можно принципом гармошки
     * тупо двумя указателями i и j будем брать подстроки и проверять их наличие в словаре
     * дальше, надо как-то понимать что определенные подстроки мы уже проверяли, как это сделать?
     * тут используем одномерный массив который говорит нам о том какие подстроки мы до этого
     * успешно заюзали в нашем как бы поиске - условно можно сказать что в массиве dp мы фиксируем
     * следующее условие - действительно ли остальная часть нашей строки s уже была встречена
     * <p>
     * еще раз - мы бегаем по нашей строке s гармошкой
     * <p>
     * то есть берем из нее подстроки l - le - lee - ee - e - leet
     * и поочереди проверяем в словаре, при этом если подстрока начинается не сначала,
     * а мы ее должны взять откуда то из середины - например code из нашей строки leetcode
     * нам надо понять а первая часть слова была в словаре?? то есть leet был в словаре
     * как это проверить - есть массив булеанов (встретили/не встретили подстроку заканчивающуюся этим индексом)
     * - каждый инт это индекс нашей строки на входе
     * и мы проверяем и мы берем подстроку и фиксируем в конечном ее индексе в массиве dp встретили мы ее
     * или нет
     * <p>
     * например дойдя до слова code нам надо проверить а leet было раньше найдено в словаре?
     * мы идем в массив dp[] берем элемент на котором leet заканчивается dp[3] если там true
     * то окей слово code (оставшаяся подстрока) ее имеет смысл искать в словаре
     * <p>
     * условно этот тупой массив dp можно было бы заменить на тупо хэшсет
     * где мы так же шли гармошкой по нашему слову и брали основную часть, и предыдущую и проверяли
     * есть ли она там
     */

    static boolean wordBreak(String s, List<String> wordDict) {
        if (s.isEmpty() || wordDict.isEmpty()) {
            return false;
        }

        int len = s.length();
        // создали массив булеанов - каждый индекс
        // - как бы говорит о том что слово заканчивающееся на него тут есть
        boolean[] dp = new boolean[len + 1];

        HashSet<String> wordDictSet = new HashSet<>(wordDict);

        // нулевой элемент равен true - это значит что пустая строка епта тут есть уже
        dp[0] = true;

        //раскручиваемся
        for (int i = 1; i < len + 1; i++) {

            // с помощью этого второго массива мы достигаем той гармошки
            //l - le - lee - ee - e - leet
            for (int j = 0; j < i; j++) {
                //берем наше как бы слово из подстроки
                String word = s.substring(j, i);
                //перво на перво проверяем - а предыдущая
                //часть нашей строки она была найдена??
                //если нет то и смысл искать наше слово в словаре
                //его нет там
                if (dp[j] && wordDictSet.contains(word)) {
                    //как только мало мальски нашли слово которе есть в словаре
                    //то метим то что такое слово есть
                    //и индекс dp[i] нужен как раз для этого

                    dp[i] = true;
                    //ну и все слово нашли можно выходить, нет смысла дальше крутится
                    break;
                }
            }

        }
        return dp[len];
    }
}
