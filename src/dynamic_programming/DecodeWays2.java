package dynamic_programming;

public class DecodeWays2 {

    public static void main(String[] args) {

        int i = numDecodings("12");
        System.out.println(i);
    }

    static int numDecodings(String s) {

        if (s.isEmpty() || (s.length()==1 && s.charAt(0) == '0')) {
            return 0;
        }

        //решается через динамическое программирование
        //каждый элемент дп массива будет говорить нам
        //сколькими возможными коомбинациями можно представить
        //укороченную подстроку
        int[] dp = new int[s.length() + 1];

        //массив для надеги будет использоваться длинной на один больше
        //по этому базовый элемент инициализируем 1
        dp[0] = 1;
        //а вот первый элемент, надо очень внимательно посмотреть что там стоит в качестве первого символа
        //"01" если вот так например то надо понимать что мы не сможем предстваить нашу строку длинной 1 как 1
        //по этому ставим тут ноль, в общем проверяем
        dp[1] = s.charAt(0) != '0' ? 1 : 0;

        //далее раскручиваем массив
        for (int i = 2; i < s.length()+1; i++) {

            //и тут рассматриваем два кейса, первый - само новое одноразрядное число
            int first = Integer.valueOf(s.substring(i - 1, i));
            //и второй кейс само итое число с соседом слева - что оно нам может дать??
            //может ли оно нам дать что-то такой колаб который даст нам новый вариант строки
            int second = Integer.valueOf(s.substring(i - 2, i));
            // проверяем  базовый случай что число одно и оно не ноль

            if (first >= 1 && first <= 9) {
                int iMinus1 = dp[i - 1];
                dp[i] = dp[i] + iMinus1;
            }
            // далее второй случай что дает колабб
            if (second >= 10 && second <= 26) {
                int iMinus2 = dp[i - 2];
                dp[i] = dp[i] + iMinus2;
            }
        }

        return dp[s.length()];
    }
}
