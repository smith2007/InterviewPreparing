package dynamic_programming;

public class UniquePaths {

    public static void main(String[] args) {

        /**
         * У нас есть робот, он расположен в левом верхнем углу абстрактной матрицы размера m x n
         * робот может ходить только вниз или вправо по матрице
         * этот робот пытается дойти до правого нижнего угла данной матрицы
         * Сколько различных уникальных коомбинаций путей есть у этого робота???
         */
    }

    static int uniquePaths(int m, int n) {
        //задача решается через динамическое программирование
        Integer[][] dp = new Integer[m][n];

        //если мы начинаем с левого верхнего угла
        //то это означает что если наш массив будет одномерный вправо или вниз
        //то у нас только один вариант достичь конца
        //потому что робот не может ходить вверх и влево
        //по этому заполняем нулевую строку и нулевой столбец единицами
        for (int i = 0; i < m; i++) {
            //потому что один единственный вариант добраться до конца
            dp[i][0] = 1;
        }
        for (int j = 0; j < n; j++) {
            dp[0][j] = 1;
        }

        //ну и дальше начинаем плясать уже от первого
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {

                //как расчитать итый житый элемент???
                //это будет сумма из элемента на строку ниже
                //и элемента на столбец правее
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        //ну и так как наши индексы начинаются с 0 то берем m-1 n-1 элемент
        return dp[m - 1][n - 1];
    }
}
